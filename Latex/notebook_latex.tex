\documentclass[10pt,a4paper]{report}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{color}
\usepackage{graphicx,color}
\usepackage{amsthm,amsfonts}
\usepackage{makeidx}
\usepackage{parskip}
\usepackage[margin=55pt]{geometry}
\usepackage[charter]{mathdesign}
\def\rmdefault{bch} % not scaled
\usepackage{titlesec}
\usepackage{hyperref}

\makeatletter
\newcommand{\zebra}[2]{%
	\begingroup
	\lst@basicstyle
	\ifodd\value{lstnumber}%
	\color{#1}%
	\else
	\color{#2}%
	\fi
	\rlap{\hspace*{\lst@numbersep}%
		\color@block{\linewidth}{\ht\strutbox}{\dp\strutbox}%
	}%
	\endgroup
}
\makeatother

\lstset 
{
	basicstyle=\footnotesize,
	numberstyle=\zebra{black!15}{black!5},
	language=C++,
	numbers=left,
	numbersep=15pt,
	tabsize=4,
	commentstyle=\color{red},
	breaklines=true;
}

\newcommand{\sectionbreak}{\clearpage}
\newcommand{\subsectionbreak}{\clearpage}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}
\title{ACM ICPC - Code Notebook}
\author{David Batista - david.batista3010@gmail.com \\ Federal University of Itajuba - Brazil}
\date{\today}
\maketitle
\tableofcontents

\chapter{Data Structure}
	
	\section{Segment Tree}
		\subsection{Segment Tree \& Lazy Propagation}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/segtree.cpp"}
		\newpage
		\subsection{Segment Tree \& Hash}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/hash.cpp"}
		\newpage
		\subsection{Quadtree}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/quadtree.cpp"}
		\newpage
		\subsection{Mergesort Segtree}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/mergesort.cpp"}
		\newpage
		\subsection{Persistent Segtree}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/persistent.cpp"}
	
	\newpage		
	\section{Fenwick Tree}
		\subsection{Fenwick Tree 1D}
			\lstinputlisting{"../Codes/Data Structure/Fenwick Tree/bit1d.cpp"}
		\newpage
		\subsection{Fenwick Tree 2D}
			\lstinputlisting{"../Codes/Data Structure/Fenwick Tree/bit2d.cpp"}
	\newpage	
	\section{Cartesian Tree}
		\subsection{Cartesian Tree}
			\lstinputlisting{"../Codes/Data Structure/Cartesian Tree/cartesian_tree.cpp"}
		\newpage
		\subsection{Implicit Cartesian Tree}
			\lstinputlisting{"../Codes/Data Structure/Cartesian Tree/implicit_cartesian_tree.cpp"}
		\newpage
		\subsection{Implicit Cartesian Tree \& Hash}
			\lstinputlisting{"../Codes/Data Structure/Cartesian Tree/cartesian_tree_hash.cpp"}
	\newpage		
	\section{Merge Sort \& Swap Count}
		\subsection{Merge Sort \& Vector}
			\lstinputlisting{"../Codes/Data Structure/Merge Sort/mergesort_swapcount.cpp"}
		\newpage
		\subsection{Merge Sort \& Array}
			\lstinputlisting{"../Codes/Data Structure/Merge Sort/mergesort_swapcount_c.cpp"}
	\newpage
	\section{Sparse Table}
		\lstinputlisting{"../Codes/Data Structure/Sparse Table/sparsetable.cpp"}
	\newpage	
	\section{SQRT Decomposition}
		\subsection{Array}
			\lstinputlisting{"../Codes/Data Structure/SQRT Decomposition/unique_values.cpp"}
		\newpage
		\subsection{Tree}
			\lstinputlisting{"../Codes/Data Structure/SQRT Decomposition/unique_values_tree.cpp"}
	
\chapter{Graph}
	\section{Components}
		\subsection{Articulations, Bridges \& Cycles}
		\newpage
		\subsection{Strongly Connected Components}
			\subsubsection{Tarjan}
				\lstinputlisting{"../Codes/Graph/DFS/tarjan.cpp"}
		\subsection{Semi-Strongly Connected Components}
	\section{Single Source Shortest Path}
		\subsection{Dijkstra}
		\newpage
		\subsection{Bellmanford}
			\lstinputlisting{"../Codes/Graph/Common Problems/Single Source Shortest Path/bellman_ford.cpp"}
		
	\section{All Pairs Shortest Path}
		\subsection{Floyd Warshall}
		
	\section{Minimum Spannig Tree}
		\subsection{Kruskal}
		\subsection{Prim}
	
	\newpage
	\section{Flow}
		\subsection{Maximum Bipartite Matching}
			\lstinputlisting{"../Codes/Graph/Flow/Maximum Bipartite Matching/maximum_bipartite_matching.cpp"}
		\newpage
		\subsection{Maximum Flow}
			\subsubsection{Dinic}
				\lstinputlisting{"../Codes/Graph/Flow/Maximum Flow/dinic.cpp"}
		\newpage
		\subsection{Minimum Cost Maximum Flow}
			Undirected graph:\\
			$u \rightarrow uu(flow, 0)$\\
			$uu \rightarrow vv(flow, cost)$\\
			$vv \rightarrow v(flow, 0)$\\
			$v \rightarrow uu(flow, 0)$\\
			$vv \rightarrow u(flow, 0)$
			\subsubsection{Dijkstra}
				\lstinputlisting{"../Codes/Graph/Flow/Maximum Flow Minimum Cost/mfmc_dijkstra.cpp"}
			\newpage
			\subsubsection{Bellmanford}
		\subsection{Minimum Cut}
			\subsubsection{Stoer Wagner}
				\lstinputlisting{"../Codes/Graph/Flow/Maximum Flow Minimum Cut/stoer_wagner.cpp"}
	
	\newpage
	\section{Tree}
		\subsection{Lowest Common Ancestor}
			\lstinputlisting{"../Codes/Graph/Tree/Lowest Common Ancestor/lca.cpp"}
		\newpage
		\subsection{Centroid Decomposition}
			\lstinputlisting{"../Codes/Graph/Tree/Centroid Decomposition/centroid_decomposition.cpp"}
		\newpage
		\subsection{Heavy Light Decomposition on Edges}
			\lstinputlisting{"../Codes/Graph/Tree/Heavy Light Decomposition/hld_edges.cpp"}
		\subsection{Heavy Light Decomposition on Vertex}
		\subsection{All-Pairs Distance \& Centroid Decomposition}
		\subsection{All-Pairs Distance \& FFT}
		
	\section{MISC}
		\subsection{2-SAT}
		
\chapter{Dynamic Programming}

	\section{Optimizations}
		\subsection{Divide and Counquer - Example 1}
			Memory can be optimized by using dp[2][N] \& dp[k\%2][m] + dp[(k-1)\%2][m]\\
			\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/divide_and_conquer.cpp"}
		\newpage
		\subsection{Divide and Counquer - Example 2}
			\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/divide_and_conquer_2.cpp"}
		\newpage
		\subsection{Convex Hull I}
			Original recurrence:\\
			\tab $dp[i]=min(dp[j]+b[j]*a[i])$ for j<i\\
			Conditions:\\
			\tab $b[j]>=b[j+1]$\\
			\tab $a[i]<=a[i+1]$\\
			Solution:\\
			Hull cht=Hull() or DynamicHull cht;\\
			cht.insertLine(b[0], dp[0])\\
			for(int i=1; i<n; i++)\\
			\{\\
				\tab dp[i]=cht.query(a[i]);\\
				\tab cht.insertLine(b[i], dp[i]);\\
			\}\\
			answer is dp[n-1];

			\subsubsection{Linear}
				\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/convex_hull_linear.cpp"}
			\newpage
			\subsubsection{Dynamic}
				\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/convex_hull_dynamic.cpp"}
		\subsection{Convex Hull II}
		\subsection{Knuth Optimization}
	\newpage
	\section{Matrix Exponentiation}
		\lstinputlisting{"../Codes/Dynamic Programming/Common Problems/Matrix Exponentiation/matrix_exp.cpp"}
	\newpage
	\section{Digits}
		\lstinputlisting{"../Codes/Dynamic Programming/Digits/dp_on_digits.cpp"}
	\newpage
	\section{Grundy Numbers}
		Positions have the following properties:
		\begin{itemize}
			\item All terminal positions are losing.
			\item If a player is able to move to a losing position then he is in a winning position.
			\item If a player is able to move only to the winning positions then he is in a losing position.
		\end{itemize}
		\lstinputlisting{"../Codes/Dynamic Programming/Common Problems/Grundy Numbers/grundy.cpp"}
\chapter{String}
	\section{Hash}
		\lstinputlisting{"../Codes/String/Hash/hash.cpp"}
	\newpage
	\section{KMP}
		\lstinputlisting{"../Codes/String/KMP/kmp.cpp"}
	\newpage
	\section{Aho Corasick}
		\lstinputlisting{"../Codes/String/Aho Corasick/aho_corasick.cpp"}
	\section{Manacher}
	\section{Z-Algorithm}
	\newpage
	\section{Suffix Array \& LCP}
		\lstinputlisting{"../Codes/String/Suffix Array/suffix_array_lcp_O(n).cpp"}
	\section{Suffix Tree}
	
\chapter{Mathematic}
	\section{Prime Numbers}
		\subsection{Erastotenes Sieve}
		\newpage
		\subsection{Linear Sieve}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/linear_sieve.cpp"}
		\newpage
		\subsection{Miller Rabin}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/miller_rabin.cpp"}
		\newpage
		\subsection{BPSW}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/bpsw.cpp"}
		\newpage
		\subsection{Primality Test}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/primality_test.cpp"}
		\newpage
		\subsection{Java Pollard Rho Decomposition}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/Pollard Rho/pollard_rho.java"}
		
	\section{Chinese Remainder Theorem}
	
	\newpage
	\section{Fast Fourier Transformation}
		\lstinputlisting{"../Codes/Mathematic/Number Theory/FFT/fft_multiply.cpp"}
	
	\section{Modular Math}
		\subsection{Multiplicative Inverse}
		\subsection{Linear All Multiplicative Inverse}
	
	\section{Gaussian Elimination}
	
	\section{Combinatorics}
	
\chapter{Geometry}
	\section{2d Template}
	\section{3d Template}
	\section{Polygon Template}
	\section{Convex Hull}
		\subsection{Graham Scan}
		\subsection{Monotone Chain}
	\section{Rotating Calipers}
	\section{KD Tree}
	\section{Range Tree}
	\section{Circle Sweep}

\chapter{Templates}
	\section{C++}
		\lstinputlisting{"../Codes/Template/cpp.cpp"}
	\section{Java}
	\newpage
	\section{Time Check}
		\lstinputlisting{"../Codes/Template/timecheck.cpp"}
	
\chapter{Formulas}
	\section{Areas}
	\section{Volumes}
	\section{Series}
	\section{Combinatorics}
	\section{Integral}
\end{document}