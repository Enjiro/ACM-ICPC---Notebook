\documentclass[10pt,a4paper]{report}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{color}
\usepackage{graphicx,color}
\usepackage{amsthm,amsfonts}
\usepackage{makeidx}
\usepackage{parskip}
\usepackage[margin=55pt]{geometry}
\usepackage[charter]{mathdesign}
\def\rmdefault{bch}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{amsmath}

\makeatletter

\newcommand{\zebra}[2]{%
	\begingroup
	\lst@basicstyle
	\ifodd\value{lstnumber}%
	\color{#1}%
	\else
	\color{#2}%
	\fi
	\rlap{\hspace*{\lst@numbersep}%
		\color@block{\linewidth}{\ht\strutbox}{\dp\strutbox}%
	}%
	\endgroup
}
\makeatother

\lstset 
{
	basicstyle=\footnotesize,
	numberstyle=\zebra{black!15}{black!5},
	language=C++,
	numbers=left,
	numbersep=15pt,
	tabsize=4,
	commentstyle=\color{red},
	breaklines=true;
}

\newcommand{\sectionbreak}{\clearpage}
\newcommand{\subsectionbreak}{\clearpage}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\begin{document}
\title{ACM ICPC - Code Notebook}
\author{David Batista - david.batista3010@gmail.com \\ Federal University of Itajuba - Brazil}
\date{\today}
\maketitle
\tableofcontents

\chapter{Data Structure}
	
	\section{Segment Tree}
		\subsection{Segment Tree \& Lazy Propagation}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/segtree.cpp"}
		\newpage
		\subsection{Segment Tree \& Hash}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/hash.cpp"}
		\newpage
		\subsection{Segment Tree \& Range Graph}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/rangegraph.cpp"}
		\newpage
		\subsection{Quadtree}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/quadtree.cpp"}
		\newpage
		\subsection{Mergesort Segtree}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/mergesort.cpp"}
		\newpage
		\subsection{Persistent Segtree}
			\lstinputlisting{"../Codes/Data Structure/Segment Tree/persistent.cpp"}
	
	\newpage		
	\section{Fenwick Tree}
		\subsection{Fenwick Tree 1D}
			\lstinputlisting{"../Codes/Data Structure/Fenwick Tree/bit1d.cpp"}
		\newpage
		\subsection{Fenwick Tree 2D}
			\lstinputlisting{"../Codes/Data Structure/Fenwick Tree/bit2d.cpp"}
	\newpage	
	\section{Cartesian Tree}
		\subsection{Cartesian Tree}
			\lstinputlisting{"../Codes/Data Structure/Cartesian Tree/cartesian_tree.cpp"}
		\newpage
		\subsection{Implicit Cartesian Tree}
			\lstinputlisting{"../Codes/Data Structure/Cartesian Tree/implicit_cartesian_tree.cpp"}
		\newpage
		\subsection{Implicit Cartesian Tree \& Hash}
			\lstinputlisting{"../Codes/Data Structure/Cartesian Tree/cartesian_tree_hash.cpp"}
	\newpage		
	\section{Merge Sort \& Swap Count}
		\subsection{Merge Sort \& Vector}
			\lstinputlisting{"../Codes/Data Structure/Merge Sort/mergesort_swapcount.cpp"}
		\newpage
		\subsection{Merge Sort \& Array}
			\lstinputlisting{"../Codes/Data Structure/Merge Sort/mergesort_swapcount_c.cpp"}
	\newpage
	\section{Sparse Table}
		\lstinputlisting{"../Codes/Data Structure/Sparse Table/sparsetable.cpp"}
	\newpage	
	\section{SQRT Decomposition}
		\subsection{Array}
			\lstinputlisting{"../Codes/Data Structure/SQRT Decomposition/unique_values.cpp"}
		\newpage
		\subsection{Tree}
			\lstinputlisting{"../Codes/Data Structure/SQRT Decomposition/unique_values_tree.cpp"}
	
\chapter{Graph}
	\section{Components}
		\subsection{Bridges}
			\lstinputlisting{"../Codes/Graph/DFS/bridges.cpp"}
		\newpage
		\subsection{Cut Points}
			\lstinputlisting{"../Codes/Graph/DFS/cutpoints.cpp"}
		\newpage
		\subsection{Strongly Connected Components}
			\subsubsection{Tarjan}
				\lstinputlisting{"../Codes/Graph/DFS/tarjan.cpp"}
		\subsection{Semi-Strongly Connected Components}
	\section{Single Source Shortest Path}
		\subsection{Dijkstra}
		\newpage
		\subsection{Bellmanford}
			\lstinputlisting{"../Codes/Graph/Common Problems/Single Source Shortest Path/bellman_ford.cpp"}
		
	\section{All Pairs Shortest Path}
		\subsection{Floyd Warshall}
		
	\section{Minimum Spannig Tree}
		\subsection{Kruskal}
		\subsection{Prim}
	
	\newpage
	\section{Flow}
		\subsection{Maximum Bipartite Matching}
			\lstinputlisting{"../Codes/Graph/Flow/Maximum Bipartite Matching/maximum_bipartite_matching.cpp"}
		\newpage
		\subsection{Maximum Flow}
			\subsubsection{Dinic}
				\lstinputlisting{"../Codes/Graph/Flow/Maximum Flow/dinic.cpp"}
		\newpage
		\subsection{Minimum Cost Maximum Flow}
			Undirected graph:\\
			$u \rightarrow uu(flow, 0)$\\
			$uu \rightarrow vv(flow, cost)$\\
			$vv \rightarrow v(flow, 0)$\\
			$v \rightarrow uu(flow, 0)$\\
			$vv \rightarrow u(flow, 0)$
			\subsubsection{Dijkstra}
				\lstinputlisting{"../Codes/Graph/Flow/Maximum Flow Minimum Cost/mfmc_dijkstra.cpp"}
			\newpage
			\subsubsection{Bellmanford}
		\subsection{Minimum Cut}
			\subsubsection{Stoer Wagner}
				\lstinputlisting{"../Codes/Graph/Flow/Maximum Flow Minimum Cut/stoer_wagner.cpp"}
	
	\newpage
	\section{Tree}
		\subsection{Lowest Common Ancestor}
			\lstinputlisting{"../Codes/Graph/Tree/Lowest Common Ancestor/lca.cpp"}
		\newpage
		\subsection{Centroid Decomposition}
			\lstinputlisting{"../Codes/Graph/Tree/Centroid Decomposition/centroid_decomposition.cpp"}
		\newpage
		\subsection{Heavy Light Decomposition on Edges}
			\lstinputlisting{"../Codes/Graph/Tree/Heavy Light Decomposition/hld_edges.cpp"}
		\subsection{Heavy Light Decomposition on Vertex}
		\newpage
		\subsection{Centroid Decomposition \& All-Pairs Distance}
			\lstinputlisting{"../Codes/Graph/Tree/Centroid Decomposition/allpairdistance.cpp"}
		\subsection{All-Pairs Distance \& FFT}

	\newpage	
	\section{MISC}
		\subsection{2-SAT}
			\lstinputlisting{"../Codes/Graph/2-SAT/2sat.cpp"}
		\newpage
		\subsection{Games on Random Graphs}
			\lstinputlisting{"../Codes/Graph/MISC/games_on_random_graphs.cpp"}
		
\chapter{Dynamic Programming}

	\section{Optimizations}
		\subsection{Divide and Counquer - Example 1}
			Memory can be optimized by using dp[2][N] \& dp[k\%2][m] + dp[(k-1)\%2][m]\\
			\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/divide_and_conquer.cpp"}
		\newpage
		\subsection{Divide and Counquer - Example 2}
			\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/divide_and_conquer_2.cpp"}
		\newpage
		\subsection{Convex Hull I}
			Original recurrence:\\
			\tab $dp[i]=min(dp[j]+b[j]*a[i])$ for j<i\\
			Conditions:\\
			\tab $b[j]>=b[j+1]$\\
			\tab $a[i]<=a[i+1]$\\
			Solution:\\
			Hull cht=Hull() or DynamicHull cht;\\
			cht.insertLine(b[0], dp[0])\\
			for(int i=1; i<n; i++)\\
			\{\\
				\tab dp[i]=cht.query(a[i]);\\
				\tab cht.insertLine(b[i], dp[i]);\\
			\}\\
			answer is dp[n-1];

			\subsubsection{Linear}
				\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/convex_hull_linear.cpp"}
			\newpage
			\subsubsection{Dynamic}
				\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/convex_hull_dynamic.cpp"}
		\subsection{Convex Hull II}
		\newpage
		\subsection{Knuth Optimization}
			\lstinputlisting{"../Codes/Dynamic Programming/Optimizations/knuth.cpp"}
	\newpage
	\section{Matrix Exponentiation}
	\[
	T=
		\begin{bmatrix}
		0 & 1 & 0 & 0 & ... & 0 \\
		0 & 0 & 1 & 0 & ... & 0 \\
		0 & 0 & 0 & 1 & ... & 0 \\
		... & ... & ... & ... & ... & ... \\
		c_{k} & c_{k-1} & c_{k-2} & c_{k-3} & ... & c_{1} \\
		\end{bmatrix}
	\]
	$$F_{N} = T^{N-1}F_{1}$$
		\lstinputlisting{"../Codes/Dynamic Programming/Common Problems/Matrix Exponentiation/matrix_exp.cpp"}
	\newpage
	\section{Digits}
		\lstinputlisting{"../Codes/Dynamic Programming/Digits/dp_on_digits.cpp"}
	\newpage
	\section{Grundy Numbers}
		Positions have the following properties:
		\begin{itemize}
			\item All terminal positions are losing.
			\item If a player is able to move to a losing position then he is in a winning position.
			\item If a player is able to move only to the winning positions then he is in a losing position.
		\end{itemize}
		\lstinputlisting{"../Codes/Dynamic Programming/Common Problems/Grundy Numbers/grundy.cpp"}
	\newpage
	\section{All Bitmasks subpatterns}
		\lstinputlisting{"../Codes/Dynamic Programming/Common Problems/all_bitmask_subpattern.cpp"}
		
\chapter{String}
	\section{Hash}
		\lstinputlisting{"../Codes/String/Hash/hash.cpp"}
	\newpage
	\section{KMP}
		\lstinputlisting{"../Codes/String/KMP/kmp.cpp"}
	\newpage
	\section{Aho Corasick}
		\lstinputlisting{"../Codes/String/Aho Corasick/aho_corasick.cpp"}
	\newpage
	\section{Manacher}
		\lstinputlisting{"../Codes/String/Manacher/manacher.cpp"}
	\newpage
	\section{Z-Algorithm}
		\lstinputlisting{"../Codes/String/Z-Algorithm/z.cpp"}
	\newpage
	\section{Suffix Array \& LCP}
		\lstinputlisting{"../Codes/String/Suffix Array/suffix_array_lcp_O(n).cpp"}
	%\section{Suffix Tree}
	
\chapter{Mathematic}
	\section{Prime Numbers}
		%\subsection{Erastotenes Sieve}
		\newpage
		\subsection{Linear Sieve}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/linear_sieve.cpp"}
		\newpage
		\subsection{Miller Rabin}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/miller_rabin.cpp"}
		\newpage
		\subsection{BPSW}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/bpsw.cpp"}
		\newpage
		\subsection{Primality Test}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/primality_test.cpp"}
		\newpage
		\subsection{Java Pollard Rho Decomposition}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Prime Numbers/Pollard Rho/pollard_rho.java"}
		
	%\section{Chinese Remainder Theorem}
	
	\newpage
	\section{Fast Fourier Transformation}
		\lstinputlisting{"../Codes/Mathematic/Number Theory/FFT/fft_multiply.cpp"}
	
	\newpage
	\section{Modular Math}
		\subsection{Multiplicative Inverse}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Modular/invmod.cpp"}
		\subsection{Linear All Multiplicative Inverse}
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Modular/all_modinv.cpp"}
		\newpage
		\subsection{Factorial}
		$(N!)\%P$ in $O(P*log_{n})$ 
			\lstinputlisting{"../Codes/Mathematic/Number Theory/Modular/fact.cpp"}
	\newpage
	\section{Gaussian Elimination}
		\lstinputlisting{"../Codes/Mathematic/Gaussian Elimination/gaussian.cpp"}
	\newpage
	\section{Combinatorics}
		$C_{n}^{k} = \dfrac{n!}{k!(n-k)!}$
		\lstinputlisting{"../Codes/Mathematic/Combinatorics/n_choose_k.cpp"}
		Improved implementation:
		\lstinputlisting{"../Codes/Mathematic/Combinatorics/n_choose_k_imp.cpp"}
	\newpage
	\section{Integral}
		$\int_{a}^{b} f(x) dx$
		\lstinputlisting{"../Codes/Mathematic/Calculus/integral.cpp"}
	
\chapter{Geometry}
	\section{2d}
		\subsection{Point Template}
			\lstinputlisting{"../Codes/Geometry/2d/point.cpp"}
		\newpage
		\subsection{Functions}
			\lstinputlisting{"../Codes/Geometry/2d/functions.cpp"}
		\newpage
		\subsection{Polygons}
			\lstinputlisting{"../Codes/Geometry/2d/polygons.cpp"}
		\newpage
		\subsection{Point Inside Polygon}
			\lstinputlisting{"../Codes/Geometry/2d/point_inside_polygon.cpp"}
		\newpage
		\subsection{Circle Line Intersection}
			\lstinputlisting{"../Codes/Geometry/2d/circle_line_intersection.cpp"}
		\newpage
		\subsection{Larges Circle Inside Convex Polygon}
			\lstinputlisting{"../Codes/Geometry/2d/largest_circle_inside_convex_polygon.cpp"}
		\newpage
		\subsection{All nearest pair of points}
			Call:\\
			$sort(a, a+n, \&cmp\_x);$\\
			$mindist = 1E20;$\\
			$rec (0, n-1);$\\
			\lstinputlisting{"../Codes/Geometry/2d/all_nearest_pair_of_points.cpp"}
				
			
	\newpage
	\section{3d}
		\subsection{Point Template}
			\lstinputlisting{"../Codes/Geometry/3d/points.cpp"}
	
	\newpage
	\section{Convex Hull}
		\subsection{Graham Scan}
			\lstinputlisting{"../Codes/Geometry/Convex Hull/graham_scan.cpp"}
		\newpage
		\subsection{Monotone Chain}
		Use 2d point template
			\lstinputlisting{"../Codes/Geometry/Convex Hull/monotonechain.cpp"}
	\newpage
	\section{Rotating Calipers}
		Only work on clockwise(or anticlockwise) ordered polygons.
		\lstinputlisting{"../Codes/Geometry/Rotating Calipers/rotating_calipers.cpp"}
	\section{KD Tree}
		\lstinputlisting{"../Codes/Geometry/KD Tree/kdtree.cpp"}
	%\section{Range Tree}
	%\section{Circle Sweep}
	
\chapter{Misc}
	\section{Josephus}
		\lstinputlisting{"../Codes/Misc/josephus.cpp"}
\chapter{Templates}
	\section{C++}
		\lstinputlisting{"../Codes/Template/cpp.cpp"}
	\newpage
	\section{Time Check}
		\lstinputlisting{"../Codes/Template/timecheck.cpp"}
	\section{Rand}
		\lstinputlisting{"../Codes/Template/rand.cpp"}
	\newpage
	\section{Java}
		\lstinputlisting{"../Codes/Template/java.java"}
	
\chapter{Formulas}
%	\section{Areas}
%	\section{Volumes}
%	\section{Series}
	\section{Combinatorics}
		\begin{itemize}
			\item Symmetry rule:
			$C_{n}^{k} = C_{n-k}^{k}$
			\item Entry-Excerpt:
			$C_{n}^{k} = \dfrac{n}{k}*C_{n-1}^{k-1}$
			\item Summation by k:
			$\sum_{k=0}^{n}C_{n}^{k} = 2^{n}$
			\item Summation by n:
			$\sum_{m=0}^{n}C_{m}^{k} = C_{n+1}^{k+1}$
			\item Summation over n and k:
			$\sum_{k=0}^{m}C_{n+k}^{k} = C_{n+m+1}^{m}$
			\item Summation of squares:
			$(C_{n}^{0})^{2} + (C_{n}^{1})^{2} + ... + (C_{n}^{n})^{2} = C_{2n}^{n}$
			\item Weighted summation:
			$1C_{n}^{1} + 2C_{n}^{2} + ... + nC_{n}^{n} = n2^{n-1}$
			\item Contact with Fibonacci numbers:
			$C_{n}^{0} + C_{n-1}^{1} + ... + C_{n-k}^{k} + ... + C_{0}^{n} = Fib_{n+1}$
		\end{itemize}
	\newpage
	\section{Catalan Numbers}
	\begin{itemize}
		\item $C_{n, m} = \binom{n+m}{n}$
		\item $C_{n} = \binom{2n}{n}$
	\end{itemize}
%	\section{Integral}
\end{document}